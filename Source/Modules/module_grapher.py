"""
module_grapher.py
=================
Data visualization and animation module for coordinate data.

Provides functions to plot original coordinates, pelvis-relative coordinates,
temporal evolution, 3D trajectories, and animated motion sequences from
the JSON coordinate files generated by the pose estimation pipeline.

Supports 4 keypoints: Pelvis, Right Shoulder, Right Elbow, Right Wrist.
Backward-compatible with older 3-keypoint JSONs (without shoulder data).

Author: Cesar Emilio CastaÃ±o Marin
"""

import json
import os
import argparse
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
import matplotlib.animation as animation
from typing import Tuple, Optional

import config


# ===========================
#  MODULE 1: Load Data
# ===========================
def load_coordinates(file_path: str) -> dict:
    """Load coordinates and timestamps from JSON file.

    Returns a dict with keys: pelvis, shoulder, shoulder_ref, wrist, wrist_ref,
    elbow, elbow_ref, timestamps. Shoulder fields may be None if not present
    in the JSON (backward compatibility with 3-keypoint data).

    Raises
    ------
    FileNotFoundError
        If the file does not exist.
    json.JSONDecodeError
        If the file contains invalid JSON.
    KeyError
        If required coordinate fields are missing from the JSON.
    """
    if not os.path.isfile(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")

    with open(file_path, "r") as file:
        data = json.load(file)

    required_keys = [config.FIELD_PELVIS, config.FIELD_WRIST_ORIGINAL,
                     config.FIELD_WRIST_RELATIVE, config.FIELD_ELBOW_ORIGINAL,
                     config.FIELD_ELBOW_RELATIVE, "timestamps"]
    for key in required_keys:
        if key not in data:
            raise KeyError(f"Missing required key '{key}' in {file_path}")

    result = {
        "pelvis": np.array(data[config.FIELD_PELVIS]),
        "wrist": np.array(data[config.FIELD_WRIST_ORIGINAL]),
        "wrist_ref": np.array(data[config.FIELD_WRIST_RELATIVE]),
        "elbow": np.array(data[config.FIELD_ELBOW_ORIGINAL]),
        "elbow_ref": np.array(data[config.FIELD_ELBOW_RELATIVE]),
        "timestamps": np.array(data["timestamps"]),
        "shoulder": None,
        "shoulder_ref": None,
    }

    if config.FIELD_SHOULDER_ORIGINAL in data and len(data[config.FIELD_SHOULDER_ORIGINAL]) > 0:
        result["shoulder"] = np.array(data[config.FIELD_SHOULDER_ORIGINAL])
        result["shoulder_ref"] = np.array(data[config.FIELD_SHOULDER_RELATIVE])

    return result

# ===========================
#  MODULE 2: Plot Functions
# ===========================

def plot_original_coordinates(pelvis: np.ndarray, wrist: np.ndarray, elbow: np.ndarray,
                              shoulder: Optional[np.ndarray] = None) -> None:
    """Plot original (absolute) coordinates of all keypoints."""
    num_points = len(pelvis)

    colors_pelvis = cm.Blues(np.linspace(config.COLORMAP_RANGE_START, 1, num_points))
    colors_wrist = cm.Reds(np.linspace(config.COLORMAP_RANGE_START, 1, num_points))
    colors_elbow = cm.Purples(np.linspace(config.COLORMAP_RANGE_START, 1, num_points))
    colors_shoulder = cm.Greens(np.linspace(config.COLORMAP_RANGE_START, 1, num_points))

    has_shoulder = shoulder is not None
    n_cols = 3 if has_shoulder else 2
    fig, axs = plt.subplots(1, n_cols, figsize=(6 * n_cols, 6))

    # ========== SUBPLOT A: Pelvis + Wrist ==========
    axs[0].set_title("Original Coordinates: Pelvis & Wrist")
    for i in range(num_points - 1):
        axs[0].plot([pelvis[i, 0], pelvis[i+1, 0]],
                    [pelvis[i, 1], pelvis[i+1, 1]], color=colors_pelvis[i])
        axs[0].plot([wrist[i, 0], wrist[i+1, 0]],
                    [wrist[i, 1], wrist[i+1, 1]], color=colors_wrist[i])

    axs[0].scatter(pelvis[:, 0], pelvis[:, 1], c=colors_pelvis, s=20, label="Pelvis")
    axs[0].scatter(wrist[:, 0], wrist[:, 1], c=colors_wrist, s=20, label="Wrist")
    axs[0].set_aspect("equal")
    axs[0].legend()
    axs[0].set_xlabel("Distance (px)")
    axs[0].set_ylabel("Distance (px)")

    # ========== SUBPLOT B: Pelvis + Elbow ==========
    axs[1].set_title("Original Coordinates: Pelvis & Elbow")
    for i in range(num_points - 1):
        axs[1].plot([pelvis[i, 0], pelvis[i+1, 0]],
                    [pelvis[i, 1], pelvis[i+1, 1]], color=colors_pelvis[i])
        axs[1].plot([elbow[i, 0], elbow[i+1, 0]],
                    [elbow[i, 1], elbow[i+1, 1]], color=colors_elbow[i])

    axs[1].scatter(pelvis[:, 0], pelvis[:, 1], c=colors_pelvis, s=20, label="Pelvis")
    axs[1].scatter(elbow[:, 0], elbow[:, 1], c=colors_elbow, s=20, label="Elbow")
    axs[1].set_aspect("equal")
    axs[1].legend()
    axs[1].set_xlabel("Distance (px)")
    axs[1].set_ylabel("Distance (px)")

    # ========== SUBPLOT C: Pelvis + Shoulder (if available) ==========
    if has_shoulder:
        axs[2].set_title("Original Coordinates: Pelvis & Shoulder")
        for i in range(num_points - 1):
            axs[2].plot([pelvis[i, 0], pelvis[i+1, 0]],
                        [pelvis[i, 1], pelvis[i+1, 1]], color=colors_pelvis[i])
            axs[2].plot([shoulder[i, 0], shoulder[i+1, 0]],
                        [shoulder[i, 1], shoulder[i+1, 1]], color=colors_shoulder[i])

        axs[2].scatter(pelvis[:, 0], pelvis[:, 1], c=colors_pelvis, s=20, label="Pelvis")
        axs[2].scatter(shoulder[:, 0], shoulder[:, 1], c=colors_shoulder, s=20, label="Shoulder")
        axs[2].set_aspect("equal")
        axs[2].legend()
        axs[2].set_xlabel("Distance (px)")
        axs[2].set_ylabel("Distance (px)")

    fig.text(
        0.5, 0.02,
        "Lighter colors represent the beginning of the movement, while darker colors indicate its end.",
        ha="center", fontsize=9, style="italic"
    )

    plt.tight_layout(rect=[0, 0.05, 1, 1])
    plt.show()

def plot_relative_coordinates(wrist_ref: np.ndarray, elbow_ref: np.ndarray,
                              shoulder_ref: Optional[np.ndarray] = None) -> None:
    """Plot pelvis-relative coordinates of wrist, elbow, and optionally shoulder."""
    num_points = len(wrist_ref)

    colors_wrist = cm.Greens(np.linspace(config.COLORMAP_RANGE_START, 1, num_points))
    colors_elbow = cm.Oranges(np.linspace(config.COLORMAP_RANGE_START, 1, num_points))
    colors_shoulder = cm.Blues(np.linspace(config.COLORMAP_RANGE_START, 1, num_points))

    has_shoulder = shoulder_ref is not None
    n_cols = 3 if has_shoulder else 2
    fig, axs = plt.subplots(1, n_cols, figsize=(6 * n_cols, 6))

    # ========== SUBPLOT A: Wrist relative ==========
    axs[0].set_title("Relative Coordinates: Wrist - Pelvis")
    for i in range(num_points - 1):
        axs[0].plot([wrist_ref[i, 0], wrist_ref[i+1, 0]],
                    [wrist_ref[i, 1], wrist_ref[i+1, 1]], color=colors_wrist[i])
    axs[0].scatter(wrist_ref[:, 0], wrist_ref[:, 1], c=colors_wrist, s=20)
    axs[0].set_aspect("equal")
    axs[0].set_xlabel("Distance (px)")
    axs[0].set_ylabel("Distance (px)")

    # ========== SUBPLOT B: Elbow relative ==========
    axs[1].set_title("Relative Coordinates: Elbow - Pelvis")
    for i in range(num_points - 1):
        axs[1].plot([elbow_ref[i, 0], elbow_ref[i+1, 0]],
                    [elbow_ref[i, 1], elbow_ref[i+1, 1]], color=colors_elbow[i])
    axs[1].scatter(elbow_ref[:, 0], elbow_ref[:, 1], c=colors_elbow, s=20)
    axs[1].set_aspect("equal")
    axs[1].set_xlabel("Distance (px)")
    axs[1].set_ylabel("Distance (px)")

    # ========== SUBPLOT C: Shoulder relative (if available) ==========
    if has_shoulder:
        axs[2].set_title("Relative Coordinates: Shoulder - Pelvis")
        for i in range(num_points - 1):
            axs[2].plot([shoulder_ref[i, 0], shoulder_ref[i+1, 0]],
                        [shoulder_ref[i, 1], shoulder_ref[i+1, 1]], color=colors_shoulder[i])
        axs[2].scatter(shoulder_ref[:, 0], shoulder_ref[:, 1], c=colors_shoulder, s=20)
        axs[2].set_aspect("equal")
        axs[2].set_xlabel("Distance (px)")
        axs[2].set_ylabel("Distance (px)")

    fig.text(
        0.5, 0.02,
        "Lighter colors represent the beginning of the movement, while darker colors indicate its end.",
        ha="center", fontsize=9, style="italic"
    )

    plt.tight_layout(rect=[0, 0.05, 1, 1])
    plt.show()

def plot_temporal(wrist_ref: np.ndarray, elbow_ref: np.ndarray, timestamps: np.ndarray,
                  shoulder_ref: Optional[np.ndarray] = None) -> None:
    """Plot time progression for wrist, elbow, and optionally shoulder (X & Y)."""

    has_shoulder = shoulder_ref is not None
    n_rows = 3 if has_shoulder else 2
    fig, axs = plt.subplots(n_rows, 2, figsize=(12, 5 * n_rows), sharex=True)

    # ------------------------
    # Row 0: Wrist X / Y
    # ------------------------
    axs[0, 0].set_title("Wrist X over Time")
    axs[0, 0].plot(timestamps, wrist_ref[:, 0], color="green")
    axs[0, 0].grid(True)
    axs[0, 0].set_xlabel("Time (seconds)")
    axs[0, 0].set_ylabel("Distance to Reference (px)")

    axs[0, 1].set_title("Wrist Y over Time")
    axs[0, 1].plot(timestamps, wrist_ref[:, 1], color="darkgreen")
    axs[0, 1].grid(True)
    axs[0, 1].set_xlabel("Time (seconds)")
    axs[0, 1].set_ylabel("Distance to Reference (px)")

    # ------------------------
    # Row 1: Elbow X / Y
    # ------------------------
    axs[1, 0].set_title("Elbow X over Time")
    axs[1, 0].plot(timestamps, elbow_ref[:, 0], color="orange")
    axs[1, 0].grid(True)
    axs[1, 0].set_xlabel("Time (seconds)")
    axs[1, 0].set_ylabel("Distance to Reference (px)")

    axs[1, 1].set_title("Elbow Y over Time")
    axs[1, 1].plot(timestamps, elbow_ref[:, 1], color="red")
    axs[1, 1].grid(True)
    axs[1, 1].set_xlabel("Time (seconds)")
    axs[1, 1].set_ylabel("Distance to Reference (px)")

    # ------------------------
    # Row 2: Shoulder X / Y (if available)
    # ------------------------
    if has_shoulder:
        axs[2, 0].set_title("Shoulder X over Time")
        axs[2, 0].plot(timestamps, shoulder_ref[:, 0], color="blue")
        axs[2, 0].grid(True)
        axs[2, 0].set_xlabel("Time (seconds)")
        axs[2, 0].set_ylabel("Distance to Reference (px)")

        axs[2, 1].set_title("Shoulder Y over Time")
        axs[2, 1].plot(timestamps, shoulder_ref[:, 1], color="darkblue")
        axs[2, 1].grid(True)
        axs[2, 1].set_xlabel("Time (seconds)")
        axs[2, 1].set_ylabel("Distance to Reference (px)")

    plt.tight_layout()
    plt.show()

def plot_3d(wrist_ref: np.ndarray, elbow_ref: np.ndarray, timestamps: np.ndarray,
            shoulder_ref: Optional[np.ndarray] = None) -> None:
    """3D trajectory of wrist, elbow, and optionally shoulder (X, Y, Time)."""

    has_shoulder = shoulder_ref is not None
    n_cols = 3 if has_shoulder else 2
    fig = plt.figure(figsize=(7 * n_cols, 6))

    # ===== Wrist =====
    ax1 = fig.add_subplot(1, n_cols, 1, projection="3d")
    ax1.plot3D(wrist_ref[:, 0], timestamps, wrist_ref[:, 1], color="green")
    ax1.set_title("3D Wrist Trajectory (X, Y, Time)")
    ax1.set_xlabel("Distance in X to Reference (px)")
    ax1.set_ylabel("Time")
    ax1.set_zlabel("Distance in Y to Reference (px)")

    # ===== Elbow =====
    ax2 = fig.add_subplot(1, n_cols, 2, projection="3d")
    ax2.plot3D(elbow_ref[:, 0], timestamps, elbow_ref[:, 1], color="purple")
    ax2.set_title("3D Elbow Trajectory (X, Y, Time)")
    ax2.set_xlabel("Distance in X to Reference (px)")
    ax2.set_ylabel("Time")
    ax2.set_zlabel("Distance in Y to Reference (px)")

    # ===== Shoulder =====
    if has_shoulder:
        ax3 = fig.add_subplot(1, n_cols, 3, projection="3d")
        ax3.plot3D(shoulder_ref[:, 0], timestamps, shoulder_ref[:, 1], color="blue")
        ax3.set_title("3D Shoulder Trajectory (X, Y, Time)")
        ax3.set_xlabel("Distance in X to Reference (px)")
        ax3.set_ylabel("Time")
        ax3.set_zlabel("Distance in Y to Reference (px)")

    plt.tight_layout()
    plt.show()

# ===========================
#  MODULE 3: Parser Wrapper
# ===========================
def plot_coordinates(args: argparse.Namespace) -> None:
    """Main function that receives parser arguments and calls the appropriate plot."""
    coords = load_coordinates(args.file)

    pelvis = coords["pelvis"]
    wrist = coords["wrist"]
    wrist_ref = coords["wrist_ref"]
    elbow = coords["elbow"]
    elbow_ref = coords["elbow_ref"]
    timestamps = coords["timestamps"]
    shoulder = coords["shoulder"]
    shoulder_ref = coords["shoulder_ref"]

    print(f"\n[INFO] Archivo cargado: {args.file}")
    print(f"[INFO] Tipo de grafica seleccionada: {args.type}")
    if shoulder is not None:
        print("[INFO] Shoulder data found (4-keypoint format)\n")
    else:
        print("[INFO] No shoulder data (3-keypoint format)\n")

    if args.type == "original":
        plot_original_coordinates(pelvis, wrist, elbow, shoulder)

    elif args.type == "relative":
        plot_relative_coordinates(wrist_ref, elbow_ref, shoulder_ref)

    elif args.type == "temporal":
        plot_temporal(wrist_ref, elbow_ref, timestamps, shoulder_ref)

    elif args.type == "3d":
        plot_3d(wrist_ref, elbow_ref, timestamps, shoulder_ref)

    elif args.type == "all":
        plot_original_coordinates(pelvis, wrist, elbow, shoulder)
        plot_relative_coordinates(wrist_ref, elbow_ref, shoulder_ref)
        plot_temporal(wrist_ref, elbow_ref, timestamps, shoulder_ref)
        plot_3d(wrist_ref, elbow_ref, timestamps, shoulder_ref)

# ===========================
#  MODULE 4: Motion Animation
# ===========================
def animate_motion(args: argparse.Namespace) -> None:
    """
    Animates Pelvis, Left Shoulder, Right Elbow, and Right Wrist (original coordinates)
    with automatic zoom, normal Y-axis, and start markers for each joint.
    Connects joints as a kinematic chain: Pelvis -> Shoulder -> Elbow -> Wrist.
    """
    json_path = args.file
    print(f"\n[INFO] Generando animacion desde: {json_path}\n")

    with open(json_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    pelvis = np.array(data[config.FIELD_PELVIS])
    elbow = np.array(data[config.FIELD_ELBOW_ORIGINAL])
    wrist = np.array(data[config.FIELD_WRIST_ORIGINAL])
    timestamps = np.array(data["timestamps"])
    metadata = data.get("metadata", {})
    fps = metadata.get("fps", 30)

    has_shoulder = config.FIELD_SHOULDER_ORIGINAL in data and len(data[config.FIELD_SHOULDER_ORIGINAL]) > 0
    if has_shoulder:
        shoulder = np.array(data[config.FIELD_SHOULDER_ORIGINAL])

    # --- Playback speed (slower for clarity) ---
    playback_speed = config.ANIMATION_PLAYBACK_SPEED
    interval = (1000 / fps) / playback_speed

    # --- Compute coordinate bounds for zoom ---
    points_list = [pelvis, elbow, wrist]
    if has_shoulder:
        points_list.append(shoulder)
    all_points = np.vstack(points_list)
    x_min, x_max = np.min(all_points[:, 0]), np.max(all_points[:, 0])
    y_min, y_max = np.min(all_points[:, 1]), np.max(all_points[:, 1])
    margin_x = (x_max - x_min) * config.COORDINATE_MARGIN_RATIO
    margin_y = (y_max - y_min) * config.COORDINATE_MARGIN_RATIO

    # --- Setup figure ---
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.set_title(f"Motion Animation (Original) - Frontal View of the Player\n{metadata.get('video_name', '')}")
    ax.set_xlim(x_min - margin_x, x_max + margin_x)
    ax.set_ylim(y_min - margin_y, y_max + margin_y)
    ax.set_xlabel("Distance (px)")
    ax.set_ylabel("Distance (px)")
    ax.grid(True, linestyle="--", alpha=0.5)

    # --- Define graphical elements ---
    scat_pelvis, = ax.plot([], [], 'o', color='blue', label="Pelvis", markersize=8)
    scat_elbow, = ax.plot([], [], 'o', color='green', label="Right Elbow", markersize=8)
    scat_wrist, = ax.plot([], [], 'o', color='red', label="Right Wrist", markersize=8)

    # Kinematic chain line: pelvis -> (shoulder) -> elbow -> wrist
    line_arm, = ax.plot([], [], '-', color='orange', lw=2, label="Arm")

    # Trails
    trail_pelvis, = ax.plot([], [], '--', color='blue', alpha=0.4)
    trail_elbow, = ax.plot([], [], '--', color='green', alpha=0.4)
    trail_wrist, = ax.plot([], [], '--', color='red', alpha=0.4)

    # Start markers (hollow circles)
    start_pelvis, = ax.plot([], [], 'o', color='blue', markersize=10, fillstyle='none', label="Start Pelvis")
    start_elbow, = ax.plot([], [], 'o', color='green', markersize=10, fillstyle='none', label="Start Elbow")
    start_wrist, = ax.plot([], [], 'o', color='red', markersize=10, fillstyle='none', label="Start Wrist")

    # Shoulder-specific elements (only if data exists)
    all_elements = [scat_pelvis, scat_elbow, scat_wrist, line_arm,
                    trail_pelvis, trail_elbow, trail_wrist,
                    start_pelvis, start_elbow, start_wrist]

    if has_shoulder:
        scat_shoulder, = ax.plot([], [], 'o', color='purple', label="Left Shoulder", markersize=8)
        trail_shoulder, = ax.plot([], [], '--', color='purple', alpha=0.4)
        start_shoulder, = ax.plot([], [], 'o', color='purple', markersize=10, fillstyle='none', label="Start Shoulder")
        all_elements.extend([scat_shoulder, trail_shoulder, start_shoulder])

    ax.legend(loc='upper left', fontsize=7)

    # --- Initialization ---
    def init():
        for element in all_elements:
            element.set_data([], [])
        return tuple(all_elements)

    # --- Update function ---
    def update(i):
        px, py = pelvis[i]
        ex, ey = elbow[i]
        wx, wy = wrist[i]

        scat_pelvis.set_data(px, py)
        scat_elbow.set_data(ex, ey)
        scat_wrist.set_data(wx, wy)

        if has_shoulder:
            sx, sy = shoulder[i]
            scat_shoulder.set_data(sx, sy)
            # Kinematic chain: Pelvis -> Shoulder -> Elbow -> Wrist
            line_arm.set_data([px, sx, ex, wx], [py, sy, ey, wy])
            trail_shoulder.set_data(shoulder[:i, 0], shoulder[:i, 1])
            start_shoulder.set_data(shoulder[0, 0], shoulder[0, 1])
        else:
            # Without shoulder: Elbow -> Wrist only
            line_arm.set_data([ex, wx], [ey, wy])

        # Trails (motion history)
        trail_pelvis.set_data(pelvis[:i, 0], pelvis[:i, 1])
        trail_elbow.set_data(elbow[:i, 0], elbow[:i, 1])
        trail_wrist.set_data(wrist[:i, 0], wrist[:i, 1])

        # Start positions (fixed)
        start_pelvis.set_data(pelvis[0, 0], pelvis[0, 1])
        start_elbow.set_data(elbow[0, 0], elbow[0, 1])
        start_wrist.set_data(wrist[0, 0], wrist[0, 1])

        return tuple(all_elements)

    # --- Create animation ---
    ani = animation.FuncAnimation(
        fig, update, frames=len(timestamps),
        init_func=init, blit=True, interval=interval, repeat=False
    )

    plt.tight_layout()
    plt.show()
